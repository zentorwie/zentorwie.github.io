---
layout: post
title: "2015 UESTC Winter Training #2"
date: 2015-01-18 01:50:16 +0800
comments: true
categories: 解题报告 ACM
---
##前言

寒假训练第二场，这一场比上一场有感觉多了，基本上键盘都在敲个不停，当然了这也和有一道码量大的H题有关系。


##Problem A	UVALive 5057	Worst Locations
没做出来（挖坑待补）

##Problem B	UVALive 5058	Counting BS
题意：给一个BST的插入序列，还有一个范围[1, M]，求用在规定范围内拿出N个不同的数出来组成一个插入序列，使得到的BST和给定序列所得到的BST形态相同。

这道题我是最后做的，差点就让我给想出来了，就卡在了求两个长度分别为n和m的有序序列有多少种合并方法，当时没想出来。

解法：对于BST的一个节点，左右子树是互不干扰的，也就是说，当我确定了要插入的n个数以后，如果左边有一个序列，右边也有一个序列，那么当我插入了当前节点后，任意时刻我可以插入任一子树的元素进去，得到的BST的形态都是一样的的。这一点画个图就知道了。

我们先不考虑选哪n个数，先求一种选数法之下有多少种排列使得BST形态一致。我们设以节点u为根的子树的数的排列有f[u]种，设l和r分别为u的左右儿子。由于左右子树互不干扰，我们可以把左子树的一种排列和右子树的一种排列组合成新的排列（保持同子树之间的先后关系），那么一共有C(x+y取y)(其中x=size[l], y=size[r])种排列（先把x+y个位置列出来，然后在里面选x个位置作为左子树的排列，剩下的作为右子树的排列，感谢YYT同学教会我）。再考虑左子树和右子树的排列数，得到

`f[u]= f[l] * f[r] * C(x + y, x),  x = size[l], y = size[r]`

(size为子树的节点数)

对于一种选数的方案，就有f(root)中排列满足题意。那么再考虑选数反案数就得到了答案。
由于n个不同的数，如果只考虑大小关系，把这n个数按照从小到大的顺序分别映射到1, 2, ..., n，映射的值之间的大小关系是不变的，也就是说在这种意义下，任意n个不同的数都是同构的。所以我们在M个数里面选N个数出来对BST来说是没啥区别的，所以有C(M取N)种选数反感。

最终答案：`f(root) * C(M, N)`

##Problem C	UVALive 5059	Playing With Stones
题意：给定N堆石子，两个人轮流选择一堆石子取出至少1个石子，但是不能取出多于当前数量一半的石子（如1个石子的一堆就是不能再取的），不能再取的人输掉游戏。

取石子，就想到Nim游戏，而且这道题就是训练指南上的原题，很久没写过博弈翻了翻大白书一看原题傻眼了，马上把书合上了，不看不看，我自己A。

解法：这是一个N个一样的子游戏的组合游戏，所以自然是判断一下N个游戏的SG值的异或和。但是SG函数怎么求呢？想了一下，不明显，那就打个表吧！一打，发现偶数的SG值是递增的，模4余1的数的SG值递增的，模8余3的数的SG值是递增的……

SG(X) = X / (2 ^ p),     p = X的二进制从低位到高位第一次出现0的位置

说白了就是看看X的二进制最低位的0在哪，把它连同更地位都砍了（位运算>>），剩下的部分的值。

组合游戏异或和为0则先手败，否则先手胜。

##Problem D	UVALive 5060	Arm Wrestling Tournament
一看不会做，再看大水题。懒得讲了，暴力模拟一下就行了。

##Problem E	UVALive 5061	Lightning Energy Report
题意：给定一颗树，有Q次操作，每次操作标记两个点，在这两个点之间的路径上的左右点都加上一个权值，每个点的初始权值为0，问最后每个点的权值为多少

一颗树/路径/操作很多，一看就想到树链剖分，不过这道题也是我做过的=_=，LRJ在紫书树链剖分部分放这道题肯定是为了提醒我们不要“手里有锤子，看什么都是钉子”。

解法：每个节点维护一个val值，对于每次操作，假设标记了u和v，加权值是w，那么在u和v上面+w，然后求u和v的LCA，假设是d，在d上面标记-w，在d的父亲上面标记-w。最后dfs一下，对于节点u，假设它的儿子的ans都算出来了，那么
ans[u] = sum(ans[v]) + val[u],  v是u的儿子
这种标记可行的原因在于，考虑一下上面的u，因为是先算儿子再算当前节点，那么某个节点的ans值就是以它为根的子树里面的所有点的val值的和。
假设标记两个节点x和y，它们的LCA为d，如果一个点p是x的子孙，那么标记对p无影响。p是y的子孙也同理。
如果p在d和x之间（不是d），那么x的标记会被推到p上面，是正确的（+w），p在d和y之间同理。
如果p就是d，那么x和y的标记都会被推到p，+2w，但d标记了-w，所以2w-w=w。
如果p是其他位置，根据dfs的遍历顺序，性质一样的是满足的（偷懒了）。

##Problem F	UVALive 5063	Just Sum It
题意：有1-9的数字，每个数字有一个数量，问用这些数字组合出的所有数的和是多少。

没做出来，后来听了王老板的讲解，还是没懂，挖个坑。

##Problem G	UVALive 5064	Serial Numbers
看都没看，据说是自动机上的DP，这种题是我的菜。挖坑。

###Problem H	UVALive 5066	Fire Drill
题意：有一栋L层的大楼，有一个消防员要去几个人，这些人在哪层楼哪个坐标都会给出，每个人还有一个分值，表示救这个人能得到的分数。给你L层楼的地图，有的格子不能走，每层楼有楼梯，走一格/上楼/下楼的时间为1s，背上人以后行动的时间变成2s。一次只能救起一个人背回起点才能继续救人。给一个时间限制S，问在限制时间内能得到的最大分值是多少？

一开始我开的就是这道，导致我1个小时都没过题，恶心度一般。

解法：BFS求出救出每个人的时间花费，这个花费等于从起点到达那个人所在为止的最短距离×3，然后跑个容量为S的01背包。思路特别简单。但是审题不认真还是要吃大亏啊。

要注意的就是每层楼可能有多条楼梯，有的人可能怎么都是救不了的。
我这道题犯了几个错误：第一，太早碰了这道题，这道题应该放在第三题的为止。第二，审题不仔细，先入为主。第三，花费初始化为0导致不能救出的人花费为0。第四，最不该犯的错误，居然对每个人都跑一次BFS，TLE了一次。下次这种题要尽量避免再犯同样的错误。

EOF


